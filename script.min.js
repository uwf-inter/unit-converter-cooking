document.addEventListener('DOMContentLoaded', () => { const sourceInput = document.getElementById('source-input'); const sourceUnitSelect = document.getElementById('source-unit'); const targetOutput = document.getElementById('target-output'); const targetUnitSelect = document.getElementById('target-unit'); const referenceList = document.getElementById('reference-list'); const resetBtn = document.getElementById('reset-btn'); const DENSITY = 1.0; const units = { 'ml': { type: 'volume', factor: 1, label: 'cc (ml)' }, 'cup': { type: 'volume', factor: 200, label: 'カップ' }, 'tbsp': { type: 'volume', factor: 15, label: '大さじ' }, 'tsp': { type: 'volume', factor: 5, label: '小さじ' }, 'g': { type: 'mass', factor: 1, label: 'g' } }; const defaultValues = { 'g': 100, 'ml': 100, 'cup': 1, 'tbsp': 1, 'tsp': 1 }; function calculate() { let val = parseFloat(sourceInput.value); let isDefaultPreview = false; if (isNaN(val)) { const sourceUnit = sourceUnitSelect.value; val = defaultValues[sourceUnit] || 1; isDefaultPreview = true; sourceInput.placeholder = val; } else { sourceInput.placeholder = defaultValues[sourceUnitSelect.value] || 1; } const sourceUnit = sourceUnitSelect.value; const targetUnit = targetUnitSelect.value; if (isDefaultPreview) { targetOutput.classList.add('placeholder-text'); } else { targetOutput.classList.remove('placeholder-text'); } let inMl = 0; switch (sourceUnit) { case 'g': inMl = val; break; case 'ml': inMl = val; break; case 'cup': inMl = val * 200; break; case 'tbsp': inMl = val * 15; break; case 'tsp': inMl = val * 5; break; }let result = 0; switch (targetUnit) { case 'g': result = inMl; break; case 'ml': result = inMl; break; case 'cup': result = inMl / 200; break; case 'tbsp': result = inMl / 15; break; case 'tsp': result = inMl / 5; break; }let displayResult = parseFloat(result.toFixed(2)); targetOutput.value = displayResult; updateReferenceList(inMl, isDefaultPreview); } function updateReferenceList(inMl, isPreview) { referenceList.innerHTML = ''; const refs = [{ unit: 'tbsp', label: '大さじ', ml: 15 }, { unit: 'tsp', label: '小さじ', ml: 5 }, { unit: 'cup', label: 'カップ', ml: 200 }, { unit: 'ml', label: 'cc (ml)', ml: 1 }, { unit: 'g', label: 'グラム', ml: 1 }]; refs.forEach(r => { if (targetUnitSelect.value === r.unit) return; let val = inMl / r.ml; let valStr = parseFloat(val.toFixed(2)); const span = document.createElement('span'); span.className = 'ref-item'; if (isPreview) span.classList.add('placeholder-text'); span.textContent = `${r.label}: ${valStr}`; referenceList.appendChild(span); }); } function formatNumber(num) { return Math.round(num * 100) / 100; } function resetAll() { sourceInput.value = ''; calculate(); } sourceInput.addEventListener('input', calculate); resetBtn.addEventListener('click', () => { resetAll(); document.querySelectorAll('.unit-select').forEach(select => { const wrapper = select.nextElementSibling; if (wrapper && wrapper.classList.contains('custom-select-wrapper')) { const trigger = wrapper.querySelector('.custom-select-trigger'); const selectedOption = select.options[select.selectedIndex]; trigger.textContent = selectedOption.text; wrapper.querySelectorAll('.custom-option').forEach(opt => { opt.classList.toggle('selected', opt.dataset.value === select.value); }); } }); calculate(); }); function setupCustomSelects() { const selects = document.querySelectorAll('.unit-select'); selects.forEach(select => { if (select.nextElementSibling && select.nextElementSibling.classList.contains('custom-select-wrapper')) { return; } const wrapper = document.createElement('div'); wrapper.className = 'custom-select-wrapper'; wrapper.dataset.forId = select.id; const trigger = document.createElement('div'); trigger.className = 'custom-select-trigger'; trigger.textContent = select.options[select.selectedIndex].text; const startUnit = select.value; const optionsContainer = document.createElement('div'); optionsContainer.className = 'custom-options'; optionsContainer.dataset.forId = select.id; Array.from(select.options).forEach(option => { const optDiv = document.createElement('div'); optDiv.className = 'custom-option'; optDiv.textContent = option.text; optDiv.dataset.value = option.value; if (option.value === startUnit) { optDiv.classList.add('selected'); } optDiv.addEventListener('click', (e) => { e.stopPropagation(); select.value = option.value; trigger.textContent = option.text; wrapper.querySelectorAll('.custom-option').forEach(o => o.classList.remove('selected')); optDiv.classList.add('selected'); optionsContainer.classList.remove('open'); calculate(); if (select.id === 'source-unit') { updateTargetAvailability(option.value); } }); optionsContainer.appendChild(optDiv); }); wrapper.appendChild(trigger); wrapper.appendChild(optionsContainer); select.parentNode.insertBefore(wrapper, select.nextSibling); wrapper.addEventListener('click', (e) => { e.stopPropagation(); document.querySelectorAll('.custom-options.open').forEach(el => { if (el !== optionsContainer) el.classList.remove('open'); }); optionsContainer.classList.toggle('open'); }); }); updateTargetAvailability(sourceUnitSelect.value); calculate(); document.addEventListener('click', () => { document.querySelectorAll('.custom-options.open').forEach(el => el.classList.remove('open')); }); } function updateTargetAvailability(sourceUnitVal) { const targetWrapper = document.querySelector('.custom-select-wrapper[data-for-id="target-unit"]'); if (!targetWrapper) return; const targetOptions = targetWrapper.querySelectorAll('.custom-option'); let currentTargetVal = targetUnitSelect.value; let collision = false; targetOptions.forEach(opt => { if (opt.dataset.value === sourceUnitVal) { opt.classList.add('hidden'); if (currentTargetVal === sourceUnitVal) { collision = true; } } else { opt.classList.remove('hidden'); } }); if (collision) { const firstVisible = Array.from(targetOptions).find(o => !o.classList.contains('hidden')); if (firstVisible) { const newVal = firstVisible.dataset.value; targetUnitSelect.value = newVal; const trigger = targetWrapper.querySelector('.custom-select-trigger'); trigger.textContent = firstVisible.textContent; targetOptions.forEach(o => o.classList.remove('selected')); firstVisible.classList.add('selected'); calculate(); } } } setupCustomSelects(); const originalServingsInput = document.getElementById('original-servings'); const desiredServingsInput = document.getElementById('desired-servings'); const recipeInput = document.getElementById('recipe-input'); const recipeOutput = document.getElementById('recipe-output'); const copyBtn = document.getElementById('copy-recipe-btn'); const scalerNote = document.getElementById('scaler-note'); function scaleRecipe() { const original = parseFloat(originalServingsInput.value); const desired = parseFloat(desiredServingsInput.value); const text = recipeInput.value; if (!original || !desired || original <= 0 || desired <= 0) { recipeOutput.value = "人数を正しく入力してね！"; return; } const ratio = desired / original; let hasFraction = false; const lines = text.split('\n'); const scaledLines = lines.map(line => { return line.replace(/(\d+(\.\d+)?)/g, (match) => { const num = parseFloat(match); if (!isNaN(num)) { let scaled = num * ratio; if (Math.abs(scaled - Math.round(scaled)) < 0.05) { scaled = Math.round(scaled); } else { scaled = parseFloat(scaled.toFixed(1)); hasFraction = true; } return scaled; } return match; }); }); recipeOutput.value = scaledLines.join('\n'); if (hasFraction) { scalerNote.classList.remove('hidden'); } else { scalerNote.classList.add('hidden'); } } [originalServingsInput, desiredServingsInput, recipeInput].forEach(el => { el.addEventListener('input', scaleRecipe); }); document.querySelectorAll('.ctrl-btn').forEach(btn => { btn.addEventListener('click', (e) => { e.preventDefault(); const targetId = btn.dataset.target; const input = document.getElementById(targetId); let val = parseInt(input.value) || 0; if (btn.classList.contains('plus')) { val++; } else if (btn.classList.contains('minus')) { val = Math.max(1, val - 1); } input.value = val; scaleRecipe(); }); }); copyBtn.addEventListener('click', () => { recipeOutput.select(); document.execCommand('copy'); const originalText = copyBtn.textContent; copyBtn.textContent = 'コピーしました！'; setTimeout(() => { copyBtn.textContent = originalText; }, 2000); }); });
